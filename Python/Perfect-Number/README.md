## Perfect Number

**Code:** Green

A __perfect number__ is a positive integer that is equal to the sum of its __positive divisors__, excluding the number itself. A __divisor__ of an integer ```x``` is an integer that can divide ```x``` evenly.

Given an integer ```n```, return ```true``` if ```n``` is a perfect number, otherwise return false.

```{python}
    def checkPerfectNumber(self, num):
        """
        :type num: int
        :rtype: bool
        """
```

__Example 1__:
```
Input: num = 28
Output: true
Explanation: 28 = 1 + 2 + 4 + 7 + 14
1, 2, 4, 7, and 14 are all divisors of 28.
```

__Example 2__: 
```
Input: num = 6
Output: true
```

__Example 3__:
```
Input: num = 496
Output: true
```
__Example 4__:
```
Input: num = 8128
Output: true
```

### Approach #1 BruteForce:

__Algorithm__:
In brute force approach, we consider every possible number to be a divisor of the given number numnumnum, by iterating over all the numbers lesser than numnumnum. Then, we add up all the factors to check if the given number satisfies the Perfect Number property. This approach obviously fails if the number ```num``` is very large. We can little optimize the brute force by breaking out of the loop early when the value of ```sum``` larger than the value of ```num```. In that case, we can directly return ```false```.

#### Complexity Analysis

    Time complexity : O(n). In worst case, we iterate over all the numbers lesser than n.

    Space complexity : O(1). Constant extra space is used.
    
### Approach #2 NinjaBruteForce:

__Algorithm__:

Similar to approach 1, but we only consider half of ```num``` as all perfect numbers has 2 as the positive divisor number.

#### Complexity Analysis

    Time complexity : O(n). Even though it is n/2, the time complexity is O(n/2) = O(n).

    Space complexity : O(1). Constant extra space is used.
    
### Approach #3 PowerMethod:

__Algorirthm__:

![Alt text](power.png?raw=true "main")

Complexity Analysis

    Time complexity : O(sqrt(n)). We iterate only over the range 1 < i ≤ sqrt(num).

    Space complexity : O(1). Constant extra space is used.

### Approach #4 Euclid-Euler Theorem:

__Algorirthm__:

Euclid proved that 2<sup>p−1</sup>(2<sup>p</sup>−1) is an even perfect number whenever 2<sup>p−1</sup> is prime, where __p__ is prime.

For example, the first four perfect numbers are generated by the formula 2<sup>p−1</sup>(2<sup>p</sup>−1), with p a prime number, as follows:

for p = 2:   2<sup>1</sup>(2<sup>2</sup> − 1) = 6
for p = 3:   2<sup>2</sup>(2<sup>3</sup> − 1) = 28
for p = 5:   2<sup>4</sup>(2<sup>5</sup> − 1) = 496
for p = 7:   2<sup>6</sup>(2<sup>7</sup> − 1) = 8128.

Prime numbers of the form 2p−12^p − 12p−1 are known as Mersenne primes. For 2p−12^p − 12p−1 to be prime, it is necessary that ppp itself be prime. However, not all numbers of the form 2p−12^p − 12p−1 with a prime ppp are prime; for example, 211−1=2047=23×892^{11} − 1 = 2047 = 23 × 89211−1=2047=23×89 is not a prime number.

You can see that for small value of ppp, its related perfect number goes very high. So, we need to evaluate perfect numbers for some primes (2,3,5,7,13,17,19,31)(2, 3, 5, 7, 13, 17, 19, 31)(2,3,5,7,13,17,19,31) only, as for bigger prime its perfect number will not fit in 64 bits.
