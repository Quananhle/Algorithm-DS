## Find the Difference

Given two strings **s** and **t** which consist of only lowercase letters. String **t** is generated by random shuffling string **s** and then add one more letter at a random position. Find the letter that was added in **t**.

```
Input:
s = "abcd"
t = "abcde"

Output:
e

Explanation:
'e' is the letter that was added.
```

### Approach 1: Sorting

**Intuition**: The first thing we might think of is, what if string t was not shuffled. If string t was not shuffled this problem would have been so easy. And then next we might end up bringing the order between the two strings. What better than sorting both the strings.
```
    i.e. sort(String t) = sort(shuffled(String s + Any character)).
```
That said, this could be one of the most brute ways of solving this problem. (There are other brute ways too. The intent is not to challenge your brute instincts :P)

**Algorithm**:

    1. Sort the string s and string t.

    2. Iterate through the length of strings and do a character by character comparison. This just checks if the current character in string t is present in string s.

    3. Once we encounter a character which is in string t but not in string s, we have found the extra character string t was hiding all this while.

#### Complexity Analysis

* **Time Complexity**: O(Nlog(N)), where N is length of the strings. Sorting is the most expensive operation of this algorithm. Sorting would take O(Nlog(N)) time. Iterating both the strings for character by character comparison would take another O(N) time.

* **Space Complexity**: O(N). The sorted character arrays would take O(N) each. An important thing to note here is that we are converting the String in java to an array first and then sorting it. That's what takes the additional space. In Python, we can just sort the given input inplace by using the sort method. If you can get around the conversion to a temporary array in Java as well, then we will have an O(1) solution here. 

### Approach 2: Using HashMap

We might just think in worst case the string is of length N and each character has a frequency of 1. This would result in a hash map of O(N)O(N)O(N) space. This is when your attention to detail comes to test.
```
    The problem states, string s and t consists of only lowercase letters.
```
The above statement implies we only have 26 characters i.e. [a, z]. Thus, we have a space complexity for just 26 characters.

It's always good to clarify this with the interviewer as now the space complexity would just be constant. Thus, this approach can also be implemented using array of length 26 as a hash table, where each index corresponds to a letter from [a, z].

**Algorithm**: 
```
    1. Store all the characters of string s in a hash map called counterS. The key would be the character and value would be number of times the character appeared in the string.

    2. Now, iterate through string t and for each character, check if it is present in the hash map counterS.

    3. If the character is present in counterS then we just decrement the corresponding value by 1.

    4. If the character is not present in counterS or has a frequency of zero in counterS it means we have found the extra character of string t.
```
**Note** - We are dropping the frequency of a character by 1 every time there is a match. This helps us find out the extra character which is present in both s and t but the number of occurrences vary. Thus keeping frequency is equally important.

#### Complexity Analysis

* **Time Complexity**: O(N), where N is length of the strings. Since, we iterate through both the strings once.

* **Space Complexity**: O(1). The problem states string s and string t have lowercase letters. Thus, the total number of unique characters and eventually buckets in the hash map possible are just 26. 
